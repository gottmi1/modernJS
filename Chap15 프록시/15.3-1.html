<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>

    // 아래는 프록시를 사용하지 않은 예시이다.

    const dog = {
      _name : 'pup',
      _age: 7,

      get name() {
        console.log(this._name);
      },
      get age() {
        console.log(this._age);
      },
      set name(newName) { // 셋 됐을 때 바꾸면서 바뀐 이름을 출력
        this._name = newName;
        console.log(this._name);
      },
      set age(newAge) {
        this._age = newAge;
        console.log(this._age);
      }
    }

    dog.name;
    dog.age;
    console.log(dog.breed);
    dog.name = "Max";
    dog.age = 8;


    // name,age 대신 _name,_age 형태의 이름을 사용했다는 점에 주목.

    // 자바스크립트 코딩 괍습에서 _기호는 프라이빗(private)속성을 정의하는 데 사용된다.
    // 즉, 클래스 내부에서만 접근 가능한 속성을 의미한ㄷ. 자브스크립트에서 이를 문법적으로 강제하지는 않지만,
    // 개발자가 프라이빗 속성을 빠르게 식별할 수 있도록 이렇게 사용하곤 한다.

    // 또한 예를 들어 다음과 같은 형태로 함수가 작성된 경우 this.name은 세터를 다시 호출하므로 무한 루프가 발생한다.
    // 이 때 속성의 이름앞에 _기호를 사용하면 문제를 피할 수 있다.
    // set name(newName) {
    //   this.name = newName;
    // }

    // 물론 이것은 다음과 같이 세터의 이름을 다른 이름으로 변경하여 얻을 수 있는 효과와 동일하다.
    // set rename(newName) {
    //  this.name = newName;
    // }

    // 예제 코드로 돌아가서 name과 age라는 두 가지 속성이 있으며 각각에 대해 게터와 세터를 만들어야 했다.
    // 여기서 breed와 같이 객체에 존재하지 않는 속성에 접근하면 언디파인드가 반환된다.
  </script>
</body>
</html>