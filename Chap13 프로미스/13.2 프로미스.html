<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  
  <script>

    // MDN에서는 프로미스를 다음과 같이 정의한다.

    // 프로미스는 비동기 작업의 최종 성공 또는 실패를 나타내는 객체이다.

    // 직접 프로미스를 한 번 만들어보자.

    // const myPromise = new Promise((resolve, reject) => {
    //   // 여기에 코드를 작성
    // })
    
    // 이런 방식으로 프로미스를 만든 후, 프로미스의 성공을 알리기 위해서는 resolve를, 실패를 알리기 위해서는 reject를 출력하면 된다.
    // 프로미스 안에서 즉시 resolve를 호출하면 어떤 값이 반환되는지 확인해보자.

    // const myPromise = new Promise((resolve, reject) => {
    //   resolve("The value we get from the promise");
    // });

    // myPromise.then(
    //   data => {
    //     console.log(data);
    //   }
    // );

    // resolve 함수의 첫 번째 매개변수로 전달된 값이 콘솔에 출력 되는 것을 확인할 수 있따.
    // setTimeout()을 사용하면 resolve가 호출되기 전까지 일정 시간을 기다릴 수 있다.

    // const myPromise = new Promise((resolve, reject) => {
    //   setTimeout(() => {
    //     resolve("The value we get from the promise");
    //   }, 2000);    
    // });

    // myPromise.then(
    //   data => {
    //     console.log(data);
    //   }
    // );

    // 2초가 지난후 resolve()를 출력.
    // 이 두 가지 예는 매우 간단한 에에 불과하지만, 프로미스는 많은 비동기 코드를 수행할 때 매우 유용하다.
    // 이 예에서는 간단하게 resolve를 호출하여 프로미스가 성공하는 경우만 살펴봤지만, 실제로는 오류도 발생하므로, reject를 이용한 오류 처리방법도 살펴보자.

    const myPromise = new Promise((resolve, reject) => {
      setTimeout(() => {
        // resolve("The value we get from the promise");
        reject(new Error("this is our error"));
      }, 2000);    
    });

    myPromise
      .then(
        data => {
          console.log(data);
        }
      )
      .catch(err => {
        console.error(err);
      })
      // reject()에 만든 new Error를 error탭에 출력

      // 프로미스가 성공할 때의 값을 얻는데에 .then()을 사용하고, 프로미스가 실패할 때의 오류를 처리하는데는 .catch()를 사용한다.

      // 출력된 오류 로그를 보면 오류가 발생한 위치를 알 수 있다. 단순히 reject("내용")으로 작성하지 않고, reject(new Error("내용"))으로 작성했기 때문.

  </script>

</body>
</html>