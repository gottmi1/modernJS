<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  
  <script>

    // MDN은 스프레드 문법을 다음과 같이 설명한다.

    // 스프레드 문법을 사용하면 0개 이상의 인수(함수 호출용) 또는 원소(배열 리터럴용)가 예상되는 위치에서 배열 표현식 또는 문자열과 같은 이터러블 항목을 확장거나,
    // 0개 이상의 키/값 쌍(객체 리터럴용)이 예상되는 위치에서 객체 표현식을 확장할 수 있다.

    // - 배열의 결합

    const veggie = ["tomato","cucumber","beans"];
    const meat = ["pork","beef","chicken"];

    const menu = [...veggie,"pasta",...meat];
    console.log(menu);
    // ['tomato', 'cucumber', 'beans', 'pasta', 'pork', 'beef', 'chicken']
    const menu33 = [veggie,"pasta",meat];
    console.log(menu33);
    // [Array(3), 'pasta', Array(3)]

    // 여기서 ...이 바로 스프레드 문법으로, veggie와 meat 배열의 모든 개별 원소를 풀어서 menu배열에 넣었고, 동시에 그 항목에 새항목 "pasta"를 넣었다.

    
    // - 배열의 복사

    const newVeggie = veggie;

    // veggie배열의 복사본을 생성한 것처럼 보이지만, 다음을 보면
    veggie.push("peas");
    console.log(newVeggie);
    
    // 이 코드에서는 기존 배열(veggie)를 수정하자 새 배열(newVeggie)도 변경되었다.
    // 그 이유는 복사본을 만든 게 아니라, 새 배열은 단순히 이전 배열을 '참조'하기 때문이다.


    // 다음은 ES5 및 이전 버전에서 일반적으로 배열의 복사본을 만드는 방법이다.

    const veggie2 = ["tomato","cucumber","beans"];
    // 빈 배열을 새로 생성하고, 기존 배열의 값을 새 배열에 이어붙인다.
    const newVeggie2 = [].concat(veggie2);
    veggie2.push("peas");
    console.log(veggie2);
    // 결과값 ["tomato","cucumber","beans","peas"];
    console.log(newVeggie2);
    // 결과값 ["tomato","cucumber","beans"];

    // 스프레드 문법을 사용하면 다음과 같은 코드로 동일한 결과를 얻을수가 있다.

    const veggie3 = ["tomato","cucumber","beans"];
    const newVeggie3 = [...veggie3];
    veggie3.push("peas")
    console.log(veggie3);
    // 결과값 ["tomato","cucumber","beans","peas"];
    console.log(newVeggie3);
    // 결과값 ["tomato","cucumber","beans"];

    // 스프레드 연산자의 문법은 ...yourArray 이런 식이다. 예제 코드에서는 변수 newVeggie를 배열 veggie의 복사본으로 만들기 위해 우선 newVeggie에 배열을 할당하고, 그 내부에 스프레드 연산자를 통해 veggie변수의 모든 원소를 넣었다.

    
    // - 함수와 스프레드 연산자

    // 인수들을 원소로 가지는 배열에 스프레드 연산자를 사용하면 함수를 쉽게 호출할 수 있다.
    
    // 기존 방식
    function doStuff (x,y,z) {
      console.log(x+y+z);
    }
    var args = [0,1,2];

    // 함수 호출, 인수 전달
    doStuff.apply(null, args);

    // 스프레드 문법 사용
    doStuff(...args);

    // 이 에제에서 doStuff 함수는 3개의 매개변수를 받는다.
    // doStuff 함수를 호출할 때 args 배열을 ...args와 같이 서서 스프레드 연산자와 함께 함수에 전달할 수 있다.
    // 이렇게 하면 굳이 .apply() 사용에 의존하지 않아도 된다.
    // 다른 예도 살펴보자.

    const name = ["Albert","Montalesi"];
    function greet(first,last){
      console.log(`hello, ${first} ${last}`);
    }

    greet(...name);
    // 배열의 두 값은 함수의 두 인수에 자동으로 할당된다.
    // 지정된 인수보다 더 많은 값을 제공하면 어떻게 될까?

    const name2 = ["Jon","Paul","Jones"];

    function greet2(first,last){
      console.log(`hello ${first} ${last}`);
    }
    greet2(...name2);
    greet2("sruname","age","name");
    // 이 예에서는 배열 내에 세 개의 값을 제공했지만, 함수에는 두 개의 인수만 있으므로 마지막 인수는 제외된다.


    // - 객체 리티럴과 스프레드(ES2018)

    // 이 기능은 ES6의 일부는 아니지만, 스프레드를 다루는 김에 ES2018에서 도입된 객체에 대한 스프레드 연산자의 예시도 같이 살펴보도록 하자.

    let person = {
      name : "Jinwon",
      surname: "Kim",
      age : 27
    }

    let clone = {...person};
    console.log(clone);
    //ES2018에 대한 자세한 내용은 20장에서 확인한다고 한다.


  </script>
  
</body>
</html>