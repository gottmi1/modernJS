<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  
  <script>

    // 세트(집합)란 어떠한 자료형의 값이든 각 원소를 '고유하게' 저장하는 객체이다

    // 세트 생성
    const family = new Set();

    // 세트에 값 추가
    family.add("Dad");
    console.log(family);
    // SEt(1) {'Dad'}

    family.add("Mom");
    console.log(family);
    // SEt(2) {'Dad','Mom'}


    family.add("Son");
    console.log(family);
    // SEt(3) {'Dad','Mom','Son'}


    family.add("Dad");
    console.log(family);
    // SEt(3) {'Dad','Mom','Son'}

    // 마지막 부분에서 Dad를 다시 추가하려고 했지만, Set는 고유한 값만 가질 수 있기 때문에 동일하게 유지됨을 볼 수 있다.
    // Set를 계속 사용해보면서 어떤 메서드들이 있는지 살펴보자.

    console.log(family.size);
    // 3

    console.log(family.keys());
    // set에는 key가 없기 때문에 keys()를 호출하면 .values()또는 .entries()를 호출한 것과 동일한 결과를 얻는다.
    console.log(family.entries());
    console.log(family.values());

    // family.delete("Dad");
    // console.log(family);
    // // Dad가 삭제 됨

    // family.clear();
    // console.log(family);
    // // family의 모든 원소가 삭제되었다.

    // Set에는 size 속성이있다. delete를 사용해서 하나의 원소를 삭제하거나, clear를 사용해서 모든 원소를 삭제할 수 있다.
    // 또한 Set에는 키가 없기 때문에 keys()를 호출하면, .entries()나, .values()과 동일한 결과를 얻는다.


    // Set에 대한 루프

    // .next()를 사용하거나 for of 루프를 사용하는 두 가지 방법으로 Set에 대해 반복할 수 있다.

    // .next() 사용
    const iterator = family.values();
    console.log(iterator.next());
    console.log(iterator.next());

    // for of 루프 사용
    for (const person of family){
      console.log(person);
    }
    // values() 메서드는 제너레이터 함수와 비슷하게 next()를 호출할 수 있는 Iterator 객체를 반환한다.

    
    // 배열에서 중복 제거하기

    // 고유한 값만 보유할 수 있는 Set의 특징을 이용하여 배열에서 중복을 제거할 수 있다.

    const myArr = ['dad','mom','son','dad','mom','daughter'];

    const set = new Set(myArr);
    console.log(set);
    // Set(4) {'dad','mom','son','daughter'}  Set 객체로 반환함

    const uniqueArr = Array.from(set);
    console.log(uniqueArr);
    // (4) ['dad','mom','son','daughter'] 배열로 반환

    // 동일한 내용을 한 줄로도 작성 가능함
    const uniqueArr2 = Array.from(new Set(myArr));
    console.log(uniqueArr2);

    // 결과를 보면 새로운 배열에는 원래 배열의 고유한 원소만 포함된다.

  </script>
</body>
</html>